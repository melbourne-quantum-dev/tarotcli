"""Data models for tarot cards and readings.

This module defines the core Pydantic models used throughout TarotCLI:
- Card: Represents a single tarot card from the 78-card Rider-Waite deck
- DrawnCard: A card as drawn in a reading, with orientation and position
- Reading: Complete reading with cards and interpretations

All models provide automatic validation, JSON serialisation, and type safety.
The models are designed to work directly with the tarot_cards_RW.jsonl
dataset without requiring dataset modifications.

INTERPRETATION LAYERS (Hermeneutical Framework):

This system implements a three-layer hermeneutical approach to tarot interpretation:

1. **Waite's Source Material (1911)**: A.E. Waite's 'Pictorial Key to the Tarot'
   provides authoritative interpretations of Rider-Waite-Smith deck symbolism.
   This is the canonical source - not generated by AI. Waite himself interpreted
   the symbolic imagery and provided traditional divinatory meanings.

2. **Static Interpretation** (`static_interpretation` field): Waite's pre-existing
   interpretations assembled and structured by spread position. No AI involvement.
   Pure presentation of source material in reading format.
   Example: "Past: The Magician (Upright)\nSkill, diplomacy..."

3. **AI Synthesis** (`interpretation` field): LLM constructs interpretation by
   combining its training data knowledge of tarot tradition with the specific Waite
   source material provided in the prompt. Waite's imagery and meanings serve as
   authoritative grounding, while the AI's broader tarot knowledge contributes
   narrative fluency and traditional context. Not mystical divination - informed
   interpretation drawn from multiple knowledge sources.

TERMINOLOGY NOTE:

Both fields use "interpretation" in their names, which can be misleading. The AI
integrates multiple sources (Waite grounding + training data knowledge) rather
than exclusively channeling one text. We maintain these field names for API
stability and user intuitiveness, but the distinction is crucial for
epistemological honesty about what the system does.

The real value: Users can choose static-only (--no-ai), AI synthesis, or compare
both modes using the lookup feature. This optionality serves educational purposes
and maintains architectural flexibility for other source datasets.

Example:
    >>> card = Card(id="ar01", name="The Magician", type="major", ...)
    >>> drawn = DrawnCard(card=card, reversed=False, position=0)
    >>> print(drawn.effective_meaning)
    "Skill, diplomacy, address, subtlety..."
"""

from typing import Literal
from enum import Enum

from pydantic import BaseModel, Field, ConfigDict


class FocusArea(str, Enum):
    """Reading focus areas for LLM context."""

    CAREER = "career"
    RELATIONSHIPS = "relationships"
    PERSONAL_GROWTH = "personal_growth"
    SPIRITUAL = "spiritual"
    GENERAL = "general"


class Card(BaseModel):
    """Single tarot card from dataset."""

    id: str = Field(
        ..., description="Unique card identifier (e.g. 'ar01' for Major Arcana 1)"
    )
    name: str = Field(..., description="Card name (e.g. 'The Magician')")
    type: Literal["major", "minor"] = Field(
        ..., description="Arcana type - major for trumps, minor for suits"
    )
    suit: str | None = Field(
        None,
        description=(
            "Suit for minor arcana (wands, cups, swords, pentacles). Null for major arcana."
        ),
    )
    value: str = Field(
        ..., description="Card value as string (e.g. '1', 'queen', 'knight')"
    )
    value_int: int = Field(
        ..., description="Numeric value for sorting (0-21 major, 1-14 minor)"
    )
    upright_meaning: str = Field(
        ...,
        description=(
            "Traditional upright interpretation from Waite's Pictorial Key to the Tarot (1911)"
        ),
    )
    reversed_meaning: str = Field(
        ...,
        description=(
            "Traditional reversed interpretation from Waite's Pictorial Key to the Tarot (1911)"
        ),
    )
    description: str = Field(
        ...,
        description=(
            "Card imagery description from Waite's original text. "
            "Used for AI interpretation context."
        ),
    )


class DrawnCard(BaseModel):
    """Card as drawn with orientation and position in spread."""

    card: Card = Field(..., description="The card object from deck")
    reversed: bool = Field(..., description="True if drawn reversed, False if upright")
    position: int = Field(..., description="Position in spread (0-indexed)")
    position_meaning: str = Field(
        default="",
        description=(
            "Position significance in spread (e.g. 'Past', 'Present', 'Future'). "
            "Assigned by spread layout during reading creation."
        ),
    )

    @property
    def effective_meaning(self) -> str:
        """
        Returns appropriate meaning based on orientation.

        Foundation note: Property ensures you always get correct meaning
        for card's current orientation without manual if/else checks.
        """
        return (
            self.card.reversed_meaning if self.reversed else self.card.upright_meaning
        )


class Reading(BaseModel):
    """Complete reading with cards and optional interpretation."""

    spread_type: str = Field(..., description="Name of spread used")
    focus_area: FocusArea = Field(..., description="Reading focus")
    question: str | None = Field(None, description="User's specific question")
    cards: list[DrawnCard] = Field(..., description="Cards drawn in order")
    interpretation: str | None = Field(
        None,
        description=(
            "AI narrative interpretation combining static source material with traditional knowledge. "
            "Not mystical divination - weaves Waite's 1911 interpretations into cohesive prose."
        ),
    )
    static_interpretation: str = Field(
        ...,
        description=(
            "Waite's 1911 card interpretations structured by spread position. "
            "No AI involvement - pure presentation of authoritative source material."
        ),
    )
    timestamp: str = Field(..., description="ISO 8601 timestamp")

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "spread_type": "three_card",
                "focus_area": "career",
                "question": "Should I pursue freelance work?",
                "interpretation": "Based on the three cards...",
                "timestamp": "2025-11-04T14:30:00Z",
            }
        }
    )
